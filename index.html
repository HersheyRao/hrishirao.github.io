<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>[[YOUR NAME]] – ENGL ePortfolio</title>

  <style>
    body {
      font-family: Arial, sans-serif;
      background: #0a0f1f;
      color: #f5f5f5;
      margin: 0;
      padding: 0;
      line-height: 1.6;
    }
    header {
      padding: 20px;
      text-align: center;
      background: #111728;
      border-bottom: 1px solid #2a3248;
    }
    h1 {
      margin: 0;
      font-size: 2rem;
    }
    main {
      max-width: 900px;
      margin: 40px auto;
      padding: 0 20px;
    }
    section {
      margin-bottom: 40px;
      padding: 20px;
      background: #111728;
      border-radius: 8px;
      border: 1px solid #2a3248;
    }
    h2 {
      margin-top: 0;
      font-size: 1.4rem;
      border-bottom: 1px solid #2a3248;
      padding-bottom: 8px;
      margin-bottom: 15px;
    }
    h3 {
      margin-top: 15px;
      font-size: 1.1rem;
    }
    a {
      color: #4db8ff;
    }
    footer {
      text-align: center;
      color: #888;
      padding: 20px;
      margin-top: 40px;
      font-size: 0.9rem;
    }
    ul {
      padding-left: 20px;
    }
  </style>
</head>

<body>

<header>
  <h1>[[YOUR NAME]] – ENGL ePortfolio</h1>
  <div>[[SEMESTER / YEAR]]</div>
</header>

<main>

   <!-- WELCOME -->
  <section>
    <h2>Welcome</h2>
    <p>
      This portfolio brings together a few projects that show how I work as a student and as a programmer. The first artifact is a data science tutorial that walks through the full pipeline on a real League of Legends dataset. The second is a Unity roguelite that focuses on movement, procedural generation, and enemy behavior. The third is a compiler project from a compiler class that translates a small functional language into a86 assembly. Taken together, they show that I can move between high level programming ideas and low level details and explain what I am doing in an understandable way.
    </p>
    <p>
      You can start by watching the video introduction, which gives a quick overview of why I picked these projects and what they say about how I work. After that, each artifact has its own section with the project link and a short explanation of what I did and why it matters. You can read the page straight through or jump to whatever area interests you. The main goal is to show the range of work I have done, from data and modeling to game development to low level systems.
    </p>
  </section>

  <!-- VIDEO INTRO -->
  <section>
    <h2>Video Introduction</h2>
    <p>[[Describe what your video covers and how it connects the artifacts.]]</p>
    <p>[[Paste your video embed code here when you have it.]]</p>
  </section>

  <!-- ARTIFACT 1 -->
  <section>
    <h2>Artifact 1: League of Legends Challenger Data Science Tutorial</h2>

    <p>
      <strong>Link to project:</strong><br>
      <a href="https://hersheyrao.github.io/" target="_blank">https://hersheyrao.github.io/</a>
    </p>

    <h3>Contextual Statement</h3>
    <p>
      This artifact is a data science tutorial website I built for CMSC320 that walks through the full data science pipeline using the then current official League of Legends Challenger dataset. I pulled data from the Riot Games API for all 300 North American Challenger players, cleaned it into a pandas dataframe, and then walked through exploratory analysis, visualizations, and basic machine learning modeling. The site is written as a step by step notebook style guide so a reader can see the raw API pulls, the code to shape the data, and the final plots and statistics in one place.
    </p>
    <p>
      This project shows that I can handle the technical side of data science and explain it in an understandable way. In this project, I had to manage API rate limits, design models for the data, and then use pandas, NumPy, matplotlib, and seaborn to explore relationships like win rate versus league points, total games played, and veteran status. I also had to decide which results actually mattered, and not just dump graphs on the reader. Lastly, I used various machine learning models on the data in order to attempt to further understand the relationships between these variables. In addition, the write up forces me to translate code and numbers into plain language so that someone who cares about League of Legends but is not a data scientist can still follow what is going on.
    </p>
    <p>
      This artifact fits my portfolio because it combines something I actually care about, high level League of Legends play, with legitimate work in data science. It shows I can take an open ended question, build my own dataset, and carry it from collection to interpretation without being spoon fed instructions. It also shows that I am comfortable presenting technical work in a public facing format, which is important for jobs where you have to communicate results to non technical people.
    </p>
  </section>

  <!-- ARTIFACT 2 -->
  <section>
    <h2>Artifact 2: Procedural Roguelite Dungeon Game (Unity)</h2>

    <p>
      <strong>Download links:</strong><br>
      Windows build:
      <a href="https://drive.google.com/drive/folders/1msKisvRfyTuTe2g4pgZl79cBMLz0tbm1?usp=sharing" target="_blank">
        Google Drive (Windows)
      </a><br>
      Mac build:
      <a href="https://drive.google.com/drive/folders/1FtyaBPDA26URHBeGGaxts9PaxIkSIRwQ?usp=sharing" target="_blank">
        Google Drive (Mac)
      </a>
    </p>

    <h3>Installation Instructions</h3>
    <p>
      The title of the application is <strong>new1</strong>. By downloading the folder and then launching the <strong>new1</strong> executable, the game should run.
    </p>

    <h3>Contextual Statement</h3>
    <p>
      This artifact is a roguelite dungeon game my group built for CMSC425 using Unity 6 and C#. The player spawns in a maze, fights bats and golems, and picks an augment after clearing the room. We made almost everything using basic Unity shapes and textures we drew ourselves. The goal was to build a simple dungeon environment that still fit a fantasy theme. We also used ideas from class like tremble effects for the bats and basic audio changes for the attacks and environment.
    </p>
    <p>
      The maze is created with a procedural system that starts with one room in the center and then places several more around it in a grid. Each room prefab has openings on four sides. When a new room is placed, the generator checks if the entrances line up. If the room is on the outside edge, unused openings are filled with walls so the layout still makes sense. The game also randomizes the number of enemies and where they spawn inside each room. Some rooms might only have a couple of bats, while others can have a mix of bats and golems spread across the space. This keeps the layout and the difficulty different every time the player loads in. Inside the rooms, the bats move unpredictably and fire magic at random, while the golems walk around until the player gets close and then chase. The movement and enemy behavior are simple but work well together, and the augment system gives the player different options for how to approach later rooms.
    </p>
    <p>
      This artifact fits my portfolio because it shows I can work on a full game loop, not just small pieces. It includes level generation, enemy randomness, enemy behavior, player upgrades, and the basic visuals needed to tie everything together. It also shows that I can think about how players experience the game, not only whether the code runs. The project required programming, teamwork, and attention to how the systems fit together, and it produced a playable result that someone can understand immediately.
    </p>
  </section>

 <!-- ARTIFACT 3 -->
  <section>
    <h2>Artifact 3: CMSC430 Fraud Compiler</h2>

    <p>
      <strong>Download full project:</strong><br>
      <a href="https://drive.google.com/file/d/1vfLfgU17F1McBwyvPVJZYcunr23TVaYt/view?usp=sharing" target="_blank">
        CMSC430 compiler code (ZIP on Google Drive)
      </a>
    </p>

    <h3>Contextual Statement</h3>
    <p>
      This artifact comes from my CMSC430 project, where we built a working compiler for a small functional programming language called Fraud. A compiler takes code written by a person and turns it into lower level instructions that a computer can actually run. In this project I wrote the part of the compiler that walks over the abstract syntax tree and generates x86 assembly for the main language features.
    </p>
    <p>
      In this file I handle expressions such as literals, primitive operations, if expressions, let and let* bindings, case expressions, lambdas, and function calls. For each form, the compiler has to decide what to put on the stack, which labels to create, and how to move values through registers so the runtime can understand them. For example, the case expression logic compiles one dispatch value, keeps it on the stack, and then generates code to compare it against each set of datums, jumping to the correct branch or the else clause. The let and let* code shows how new variables are pushed, added to the environment, and then cleaned up afterward.
    </p>
    <p>
      I chose this as an artifact because it shows that I can work at the level where programming languages and hardware meet. For someone who is not technical, the easiest way to think about it is that this code is part of the “translator” that turns a high level language into concrete steps a machine can follow. It required careful attention to correctness, stack layout, and control flow, and it balances that detail with keeping the structure of the compiler understandable. Together with the other two artifacts, it shows that I can work across data science, game development, and low level systems work.
    </p>

    <h3>Code Snippet</h3>
    <pre><code>#lang racket
(provide compile
         compile-e)

(require "ast.rkt")
(require "compile-ops.rkt")
(require "types.rkt")
(require a86/ast a86/registers)

;; ClosedExpr -> Asm
(define (compile e)
  (prog (Global 'entry)
        (Extern 'peek_byte)
        (Extern 'read_byte)
        (Extern 'write_byte)
        (Extern 'raise_error)
        (Label 'entry)
        (Mov r11 rbx)
        (Sub rsp (* 8 14))
        (Mov (Mem rsp 0)   r12)
        (Mov (Mem rsp 8)   r13)
        (Mov (Mem rsp 16)  r14)
        (Mov (Mem rsp 24)  r15)
        (Mov (Mem rsp 32)  rbx)
        (Mov (Mem rsp 40)  rbp)
        (Mov (Mem rsp 48)  rdi)
        (Mov (Mem rsp 56)  rsi)
        (Mov (Mem rsp 64)  r8)
        (Mov (Mem rsp 72)  r9)
        (Mov (Mem rsp 80)  r10)
        (Mov (Mem rsp 88)  r11)
        (Mov (Mem rsp 96)  rax)
        (Mov (Mem rsp 104) rcx)
        (Mov (Mem rsp 112) rdx)
        (Mov rbx r11)
        (compile-e e '())
        (Mov r12 (Mem rsp 0))
        (Mov r13 (Mem rsp 8))
        (Mov r14 (Mem rsp 16))
        (Mov r15 (Mem rsp 24))
        (Mov rbx (Mem rsp 32))
        (Mov rbp (Mem rsp 40))
        (Mov rdi (Mem rsp 48))
        (Mov rsi (Mem rsp 56))
        (Mov r8  (Mem rsp 64))
        (Mov r9  (Mem rsp 72))
        (Mov r10 (Mem rsp 80))
        (Mov r11 (Mem rsp 88))
        (Mov rax (Mem rsp 96))
        (Mov rcx (Mem rsp 104))
        (Mov rdx (Mem rsp 112))
        (Add rsp (* 8 14))
        (Ret)))

;; Expr CEnv -> Asm
(define (compile-e e cenv)
  (match e
    [(Lit d)
     (compile-datum d)]
    [(Prim0 p)
     (compile-op0 p)]
    [(Prim1 p e1)
     (seq (compile-e e1 cenv)
          (compile-op1 p))]
    [(Prim2 p e1 e2)
     (seq (compile-e e1 cenv)
          (Push rax)
          (compile-e e2 (cons #f cenv))
          (compile-op2 p))]
    [(Case e ds es el)
     (let* ([m (length ds)]
            [l-end  (gensym 'case_end)]
            [l-hits (build-list m (λ (_) (gensym 'case_hit)))])
       (seq
        (compile-e e cenv)
        (Push rax)
        (foldl
         (λ (i acc)
           (let* ([datums (list-ref ds i)]
                  [l-next (gensym 'case_next)])
             (seq acc
                  (foldl
                   (λ (d acc2)
                     (seq acc2
                          (Mov rax (Mem 0 rsp))
                          (Mov r9  (value->bits d))
                          (Cmp rax r9)
                          (Je (list-ref l-hits i))))
                   (seq)
                   datums)
                  (Jmp l-next)
                  (Label (list-ref l-hits i))
                  (compile-e (list-ref es i) cenv)
                  (Jmp l-end)
                  (Label l-next))))
         (seq)
         (range 0 m))
        (compile-e el cenv)
        (Label l-end)
        (Add rsp 8)))]
    [(Let x e1 e2)
     (let* ([n (length x)] [c* (append (reverse x) cenv)])
       (seq
        (for/fold ([acc (seq)]) ([ei e1])
          (seq acc
               (compile-e ei cenv)
               (Push rax)))
        (compile-e e2 c*)
        (Add rsp (* 8 n))))]
    [(Var x)
     (seq (Mov rax rsp)
          (Add rax (lookup x cenv))
          (Mov rax (Mem 0 rax)))]))</code></pre>

  </section>

</main>

<footer>
  © [[YEAR]] [[YOUR NAME]]
</footer>

</body>
</html>
